- unlike natural languages such as English or Chinese, computer languages must be precise. Both their form (syntax) and meaning (semantics) must be specified without ambiguity.
	syntax - the way you say something
	semantics - what that something means
- implementing the insertion sort algorithm in 5 different programming languages would yield 5 very different syntax specifications for that algorithm, but each program would carry the same semantic information.
- in theory, a scanner is a DFA (deterministic finite automaton) that recognizes the tokens of a language
	- a scanner can be automatically generated from regular expressions
- a parser is a deterministic PDA (push down automaton) that recognizes the language's context free syntax.
	- a parser can be automatically generated from a CFG (context-free grammar)
- tokens are the basic building blocks of programs -- the shortest strings of characters with individual meaning. 
- tokens are constructed from individual characters using just three kinds of formal rules: concatenation, alternation (choice among a finite set of alternatives), and Kleene closure (repetition an arbitrary number of times)
	- Specifying most of the rest of what we intuitively think of as syntax requires one additional kind of rule: recursion.
- any set of strings that can be defined in terms of the first three rules (concatenation, alternation, and Kleene closure) is called a regular set, or sometimes a regular language.
	- regular sets are generated by regular expressions and recognized by scanners.
- there is virtually no difference between regular sets, regular expressions, and finite automatons.
- Any set of strings that can be defined by the first three rules plus recursion are called context free languages (CFLs).
	- CFLs are generated by context-free grammars (CFGs) and recognized by parsers
- To specify tokens, we use the notation of regular expressions.
- a regular expression is one of the following:
	1. a character
	2. the empty string (epsilon)
	3. Two regular expressions next to eachother
	4. Two regular expressions separated by a vertical bar '|'
	5. a regular expression followed by a kleene star (concatenation of 0 or more strings)
- Dialects of Fortran (prior to Fortran 90) use a fixed format, with 72 characters per line (the width of a paper punch card on which programs were once stored)
- regular expressions work well for defining tokens. They are unable, however, to specify nested constructs, which are central to programming languages.
- each of the rules in a context free grammar is known as a production. The symbols on the left hand sides are known as variables or non-terminals.
- Symbols that make up the strings derived from the grammar are known as terminals. They cannot appear on the lefthand side of any production.
- The notation for context-free grammars is sometimes called Backus-Naur form (BNF), in honor of John Backus and Peter Naur, who devised it for the definition of the Algol-60 programming language.
	- John Backus is also invented the Fortran programming language. He received the turing award in 1977.
- strictly speaking, the Kleene star and meta-level parentheses are not allowed in BNF.
- A Kleene Plus indicates one or more instances
- Extended Backus-Naur Form (EBNF) is simply BNF but augmented with extra operators (Kleene star, Kleene plus, meta-level parentheses, etc..)
- a context free grammar shows us how to generate a syntactically valid string of terminals
- each string of symbols at every given point in a derivation is called a sentential form.
	- the final sentential form, consisting of only terminals, is called the yield of the derivation
- a grammar that allows the construction of more than one parse tree for some string of terminals is said to be ambiguous.
- there are infinitely many CFGs for every CFL.
- one major point to think about when designing a CFG is how it handles associativity and precedence in arithmetic expressions.
- ambiguous context-free grammars are allowed by most parser generators by means of disambiguating rules.
	
